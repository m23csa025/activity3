# -*- coding: utf-8 -*-
"""M23CSA025_DLOps_ClassAssignment2_Q2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XujtnBuGNp831PMLhRJcmJgbCZLTLxF0

**DL Ops Class Assignment 2 : Q2**

Mandar Bhalerao (M23CSA025)

Question 2: Finetuning a pre-trained network and the optimizers [5+3x5=20 marks]

Finetune the pre-trained ResNet101 model (trained with the ImageNet dataset and made available on the PyTorch torchvision server) on the X dataset for classification tasks and plot curves for training loss and training accuracy. Report the final top-5 test accuracy. Perform the
above task with any 3 optimizers from the following list.
1. Adam
2. Adagrad
3. Adadelta

4. RMSprop

X = STL10, if the last digit of your roll no. MOD 3 == 0

X = SVHN, if the last digit of your roll no. MOD 3 == 1

**X = FashionMNIST, if the last digit of your roll no. MOD 3 == 2**
"""

import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import datasets, transforms, models
from torch.utils.data import DataLoader, Subset
import numpy as np
import matplotlib.pyplot as plt




# Define transforms for FashionMNIST dataset
transform_fashion_mnist = transforms.Compose([
    transforms.Grayscale(num_output_channels=3),  # Convert grayscale to RGB
    transforms.Resize((224, 224)),  # Resize images to match ResNet101 input size
    transforms.ToTensor(),
    transforms.Normalize((0.5,), (0.5,))
])

# Load FashionMNIST dataset
train_dataset_fashion_mnist = datasets.FashionMNIST(root='./data', train=True, download=True, transform=transform_fashion_mnist)
test_dataset_fashion_mnist = datasets.FashionMNIST(root='./data', train=False, download=True, transform=transform_fashion_mnist)


subset_train = Subset(train_dataset_fashion_mnist, range(10000))
subset_test = Subset(test_dataset_fashion_mnist, range(5000))

# Define data loaders
train_loader_fashion_mnist = DataLoader(subset_train, batch_size=200, shuffle=True)
test_loader_fashion_mnist = DataLoader(subset_test, batch_size=200, shuffle=False)

# Load pre-trained ResNet50 model
resnet_fashion = models.resnet50(pretrained=True)

# Freeze all layers except the final fully connected layer
for param in resnet_fashion.parameters():
    param.requires_grad = False

# Modify the last fully connected layer to match FashionMNIST (10 classes)
num_features_resnet = resnet_fashion.fc.in_features
resnet_fashion.fc = nn.Linear(num_features_resnet, 10)  # 10 classes in FashionMNIST

# Define optimizers
optimizers_fashion = {
    'Adam': optim.Adam(resnet_fashion.parameters(), lr=0.001),
    'Adagrad': optim.Adagrad(resnet_fashion.parameters(), lr=0.001),
    'RMSprop': optim.RMSprop(resnet_fashion.parameters(), lr=0.001)
}

# Define loss function
criterion_fashion = nn.CrossEntropyLoss()

# Check device availability
device_fashion = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print("Using device:", device_fashion)

# Move model to device
resnet_fashion.to(device_fashion)

# Train the model with different optimizers
results_fashion = {}
for optimizer_name, optimizer in optimizers_fashion.items():
    print(f"Training with {optimizer_name} optimizer...")
    resnet_fashion.train()
    losses_fashion = []
    accuracies_fashion = []
    for epoch in range(3):  # 3 epochs for demonstration
        running_loss_fashion = 0.0
        correct_fashion = 0
        total_fashion = 0
        for images_fashion, labels_fashion in train_loader_fashion_mnist:
            images_fashion, labels_fashion = images_fashion.to(device_fashion), labels_fashion.to(device_fashion)  # Move data to GPU
            optimizer.zero_grad()
            outputs_fashion = resnet_fashion(images_fashion)
            loss_fashion = criterion_fashion(outputs_fashion, labels_fashion)
            loss_fashion.backward()
            optimizer.step()

            running_loss_fashion += loss_fashion.item()
            _, predicted_fashion = torch.max(outputs_fashion, 1)
            total_fashion += labels_fashion.size(0)
            correct_fashion += (predicted_fashion == labels_fashion).sum().item()

        epoch_loss_fashion = running_loss_fashion / len(train_loader_fashion_mnist)
        epoch_accuracy_fashion = correct_fashion / total_fashion
        losses_fashion.append(epoch_loss_fashion)
        accuracies_fashion.append(epoch_accuracy_fashion)

        print(f"Epoch [{epoch + 1}/5], Loss: {epoch_loss_fashion:.4f}, Accuracy: {epoch_accuracy_fashion:.4f}")

    results_fashion[optimizer_name] = {
        'loss': losses_fashion,
        'accuracy': accuracies_fashion
    }

# Plot curves for training loss and training accuracy
plt.figure(figsize=(10, 5))
for optimizer_name, result in results_fashion.items():
    plt.plot(result['loss'], label=f'{optimizer_name} Loss')
plt.title('Training Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.show()

plt.figure(figsize=(10, 5))
for optimizer_name, result in results_fashion.items():
    plt.plot(result['accuracy'], label=f'{optimizer_name} Accuracy')
plt.title('Training Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

# Test the model and report top-5 test accuracy
resnet_fashion.eval()
top5_correct_fashion = 0
total_fashion = 0
with torch.no_grad():
    for images_fashion, labels_fashion in test_loader_fashion_mnist:
        images_fashion, labels_fashion = images_fashion.to(device_fashion), labels_fashion.to(device_fashion)
        outputs_fashion = resnet_fashion(images_fashion)
        _, predicted_top5_fashion = torch.topk(outputs_fashion, k=5, dim=1)  # Get top-5 predictions
        top5_correct_fashion += sum(labels_fashion.unsqueeze(1).eq(predicted_top5_fashion)).item()
        total_fashion += labels_fashion.size(0)

top5_accuracy_fashion = top5_correct_fashion / total_fashion
print(f'Top-5 Test Accuracy: {top5_accuracy_fashion:.4f}')